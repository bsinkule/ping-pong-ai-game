<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Doubles Ping Pong</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #1a1a1a;
        font-family: Arial, sans-serif;
        overflow: hidden;
        user-select: none;
      }

      #gameCanvas {
        display: block;
        background: #2d5a2d;
        border: 2px solid #fff;
        cursor: crosshair;
      }

      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-size: 18px;
        z-index: 100;
      }

      #powerMeter {
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        width: 30px;
        height: 200px;
        background: rgba(255, 255, 255, 0.3);
        border: 2px solid white;
        border-radius: 15px;
        z-index: 100;
      }

      #powerFill {
        position: absolute;
        bottom: 0;
        width: 100%;
        background: linear-gradient(to top, #ff4444, #ffff44, #44ff44);
        border-radius: 0 0 13px 13px;
        transition: height 0.1s;
      }

      #aimArrow {
        position: absolute;
        width: 4px;
        background: #ffff44;
        transform-origin: bottom center;
        z-index: 100;
        display: none;
      }

      #controls {
        position: absolute;
        bottom: 10px;
        left: 10px;
        color: white;
        font-size: 14px;
        z-index: 100;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
      <div>
        Team 1: <span id="score1">0</span> | Team 2: <span id="score2">0</span>
      </div>
      <div id="gameInfo">Serving: Player 1</div>
      <div id="instructions">
        Your serve! Click/tap to move, hold to aim & power
      </div>
    </div>

    <div id="powerMeter">
      <div id="powerFill"></div>
    </div>

    <div id="aimArrow"></div>

    <div id="controls">
      ðŸ’» Mouse: Click to move, hold to aim & shoot<br />
      ðŸ“± Mobile: Tap to move, hold to aim & shoot
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const powerFill = document.getElementById("powerFill");
      const aimArrow = document.getElementById("aimArrow");

      // Game state
      let gameState = {
        score1: 0,
        score2: 0,
        currentServer: 0,
        servesLeft: 5,
        currentHitter: 0,
        ballInPlay: false,
        gameWon: false,
      };

      // Add at the top, after gameState:
      let lastHitter = [0, 2]; // [team1Last, team2Last]
      let allowedHitter = 0; // index of player allowed to hit next
      let ballStuck = false;
      let stuckPlayer = null;
      // Add at the top, after input handling
      let aiPlacement = 0; // Current AI placement for UI
      let aiPlacementTimeout = null;
      let showingAIPlacement = false;
      let currentPlacementOwner = null; // 'user' or 'ai'
      let aiCharging = false; // AI is preparing to hit
      let aiWaitingForBallToLeave = false; // Prevents retriggering AI charge until ball leaves zone
      let aiChargingPlayer = null; // Which AI is charging (2 or 3)
      let ballStuckToAI = false;
      let lastAIHitter = null; // Track last AI who hit
      // Bounce ping animation state
      let bouncePing = null; // {x, y, time, color}
      let bounceState = null; // {y, shown, color}
      let teammatePlacement = 0;
      let hasBounced = false;
      let hasBouncedIn = false;
      // Add at the top, after other global variables:
      let hasBouncedSinceLastHit = false;
      let isServeInProgress = false;

      // Game objects - initialize with default values
      let table = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        netY: 0,
      };

      let ball = {
        x: 0,
        y: 0,
        vx: 0,
        vy: 0,
        radius: 8,
        trail: [],
      };

      let players = [
        { x: 0, y: 0, targetX: 0, isUser: true, team: 1 },
        { x: 0, y: 0, targetX: 0, isUser: false, team: 1 },
        { x: 0, y: 0, targetX: 0, isUser: false, team: 2 },
        { x: 0, y: 0, targetX: 0, isUser: false, team: 2 },
      ];

      // Input handling
      let inputStart = null;
      let charging = false;
      let chargePower = 0;
      let aimAngle = 0;

      // At the top, define the serve rotation order:
      const serveRotation = [0, 3, 1, 2]; // Player indices: 1, 4, 2, 3
      let serveRotationIndex = 0;

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Maintain 1.8:1 aspect ratio (portrait: height:width)
        const aspect = 1.8;
        let maxTableHeight = window.innerHeight * 0.7; // Reduce from 0.8 to 0.7
        let maxTableWidth = window.innerWidth * 0.9;
        let tableHeight = maxTableHeight;
        let tableWidth = tableHeight / aspect;
        if (tableWidth > maxTableWidth) {
          tableWidth = maxTableWidth;
          tableHeight = tableWidth * aspect;
        }
        table.width = tableWidth;
        table.height = tableHeight;
        table.x = (canvas.width - table.width) / 2;
        table.y = (canvas.height - table.height) / 2;
        table.netY = table.y + table.height / 2;

        // Position players (move further back, 6% gap from end lines)
        players[0].x = players[0].targetX = table.x + table.width * 0.3;
        players[0].y = table.y + table.height * 0.94;
        players[1].x = players[1].targetX = table.x + table.width * 0.7;
        players[1].y = table.y + table.height * 0.94;
        players[2].x = players[2].targetX = table.x + table.width * 0.3;
        players[2].y = table.y + table.height * 0.06;
        players[3].x = players[3].targetX = table.x + table.width * 0.7;
        players[3].y = table.y + table.height * 0.06;

        // Position ball
        ball.x = players[gameState.currentServer].x;
        ball.y = players[gameState.currentServer].y - 50; // Start further from player

        // In resizeCanvas, after setting currentServer:
        allowedHitter = gameState.currentServer;
        lastHitter = [0, 2];
      }

      function drawTable() {
        // Table surface
        ctx.fillStyle = "#0d4d0d";
        ctx.fillRect(table.x, table.y, table.width, table.height);

        // Table border
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 4;
        ctx.strokeRect(table.x, table.y, table.width, table.height);

        // Net
        ctx.fillStyle = "#fff";
        ctx.fillRect(table.x, table.netY - 3, table.width, 6);

        // Center line
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(table.x + table.width / 2, table.y);
        ctx.lineTo(table.x + table.width / 2, table.netY - 3);
        ctx.moveTo(table.x + table.width / 2, table.netY + 3);
        ctx.lineTo(table.x + table.width / 2, table.y + table.height);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw bounce ping animation if active
        if (bouncePing) {
          const elapsed = performance.now() - bouncePing.time;
          if (elapsed < 900) {
            const maxRadius = 20;
            const minRadius = 6;
            const radius =
              minRadius + (maxRadius - minRadius) * (elapsed / 900);
            ctx.save();
            ctx.globalAlpha = 0.5 * (1 - elapsed / 900) + 0.3;
            ctx.beginPath();
            ctx.arc(bouncePing.x, bouncePing.y, radius, 0, Math.PI * 2);
            ctx.fillStyle = "#eee8"; // subtle light grey, semi-transparent
            ctx.fill();
            ctx.globalAlpha = 1 - elapsed / 900;
            ctx.lineWidth = 5;
            ctx.strokeStyle = "#eee";
            ctx.shadowColor = "#eee";
            ctx.shadowBlur = 18;
            ctx.stroke();
            ctx.restore();
          } else {
            bouncePing = null;
          }
        }
      }

      function drawPlayers() {
        players.forEach((player, i) => {
          ctx.save();
          if (i !== allowedHitter) {
            ctx.globalAlpha = 0.3; // Dim everyone except allowedHitter
          }
          // Player paddle
          ctx.fillStyle = player.isUser
            ? "#4CAF50"
            : player.team === 1
            ? "#2196F3"
            : "#F44336";
          ctx.beginPath();
          ctx.arc(player.x, player.y, 18, 0, Math.PI * 2);
          ctx.fill();

          // Player number
          ctx.fillStyle = "#fff";
          ctx.font = "bold 14px Arial";
          ctx.textAlign = "center";
          ctx.fillText(i + 1, player.x, player.y + 5);

          // Highlight current hitter
          // if (i === gameState.currentHitter) {
          //   ctx.strokeStyle = "#ffff44";
          //   ctx.lineWidth = 4;
          //   ctx.beginPath();
          //   ctx.arc(player.x, player.y, 25, 0, Math.PI * 2);
          //   ctx.stroke();
          // }
          ctx.restore();
        });
      }

      function drawBall() {
        if (ball.trail.length > 1) {
          // Ball trail
          ctx.strokeStyle = "rgba(255,255,255,0.5)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          for (let i = 0; i < ball.trail.length - 1; i++) {
            const alpha = i / ball.trail.length;
            ctx.globalAlpha = alpha;
            ctx.moveTo(ball.trail[i].x, ball.trail[i].y);
            ctx.lineTo(ball.trail[i + 1].x, ball.trail[i + 1].y);
          }
          ctx.stroke();
          ctx.globalAlpha = 1;
        }

        // Ball
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#ccc";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      }

      function updateBall() {
        if (!gameState.ballInPlay) return;

        // Update trail
        ball.trail.push({ x: ball.x, y: ball.y });
        if (ball.trail.length > 10) ball.trail.shift();

        ball.x += ball.vx;
        ball.y += ball.vy;

        // Ball physics (top-down view: no gravity)
        // ball.vx *= 0.95; // Stronger friction
        // ball.vy *= 0.95;

        // --- Out on volley wide ---
        const left = table.x;
        const right = table.x + table.width;
        const margin = 20;
        if (
          ball.x < margin ||
          ball.x > canvas.width - margin ||
          ball.y < table.y ||
          ball.y > table.y + table.height
        ) {
          let lastHitterIdx =
            typeof lastHitterIndex !== "undefined"
              ? lastHitterIndex
              : allowedHitter < 2
              ? lastHitter[1]
              : lastHitter[0];
          let hitterTeam = lastHitterIdx < 2 ? 1 : 2;
          let opponentTeam = hitterTeam === 1 ? 2 : 1;
          if (hasBouncedSinceLastHit) {
            scorePoint(hitterTeam);
            hasBouncedIn = false;
            hasBouncedSinceLastHit = false;
            return;
          } else {
            scorePoint(opponentTeam);
            hasBouncedIn = false;
            hasBouncedSinceLastHit = false;
            return;
          }
        }

        // Check paddle collisions
        players.forEach((player, i) => {
          if (i !== allowedHitter) return;
          const dist = Math.sqrt(
            (ball.x - player.x) ** 2 + (ball.y - player.y) ** 2
          );
          if (dist < (player.isUser ? ball.radius + 18 : 40)) {
            // --- Diagonal serve enforcement on paddle collision (for full power serves) ---
            if (isServeInProgress) {
              const centerX = table.x + table.width / 2;
              const server = gameState.currentServer;
              let correctSide = null;
              // Player 0 and 2: must serve to right half (x > centerX)
              // Player 1 and 3: must serve to left half (x < centerX)
              if (server === 0 || server === 2) correctSide = "right";
              else correctSide = "left";
              if (
                (correctSide === "right" && ball.x <= centerX) ||
                (correctSide === "left" && ball.x >= centerX)
              ) {
                // Serve is out, award point to opponent
                isServeInProgress = false;
                let opponentTeam = players[server].team === 1 ? 2 : 1;
                scorePoint(opponentTeam);
                hasBouncedIn = false;
                hasBouncedSinceLastHit = false;
                return;
              } else if (ball.x < table.x || ball.x > table.x + table.width) {
                // Serve is wide, out
                isServeInProgress = false;
                let opponentTeam = players[server].team === 1 ? 2 : 1;
                scorePoint(opponentTeam);
                hasBouncedIn = false;
                hasBouncedSinceLastHit = false;
                return;
              } else {
                // Serve is in, allow regular gameplay
                isServeInProgress = false;
                hasBouncedIn = true;
                hasBouncedSinceLastHit = false;
                // Do not return; allow normal hit logic to proceed
              }
            }
            // --- Out on volley wide ---
            // If the ball is outside the table width and has not bounced, count as out
            const left = table.x;
            const right = table.x + table.width;
            if (!hasBouncedIn && (ball.x < left || ball.x > right)) {
              // Determine which team hit last using lastHitter
              let lastHitterIdx =
                allowedHitter < 2 ? lastHitter[1] : lastHitter[0];
              let hitterTeam = lastHitterIdx < 2 ? 1 : 2;
              let opponentTeam = hitterTeam === 1 ? 2 : 1;
              // Check if the ball crossed the net (i.e., y is on the opponent's side)
              if (
                (hitterTeam === 1 && ball.y <= table.netY) ||
                (hitterTeam === 2 && ball.y >= table.netY)
              ) {
                // Ball crossed the net and went out wide: point to opponent
                scorePoint(opponentTeam);
              } else {
                // Ball did not cross the net: point to opponent (failed shot)
                scorePoint(opponentTeam);
              }
              hasBouncedIn = false;
              hasBouncedSinceLastHit = false;
              return;
            }
            // Before setting a new bounceState, show the previous one if not yet shown
            if (bounceState && !bounceState.shown) {
              bouncePing = {
                x: ball.x,
                y: ball.y,
                time: performance.now(),
                color: bounceState.color,
              };
              bounceState.shown = true;
            }
            // For AI teammates and opponents (players 1, 2, 3)
            if (!player.isUser && !aiCharging && aiChargingPlayer === null) {
              aiCharging = true;
              aiChargingPlayer = i;
              let rand = Math.random();
              let placement;
              if (rand < 0.85) {
                placement = 0.5 + Math.random() * 0.4; // 0.5-0.9
              } else {
                placement =
                  Math.random() < 0.5
                    ? 0.2 + Math.random() * 0.28
                    : 0.91 + Math.random() * 0.09;
              }
              if (i === 1) teammatePlacement = placement;
              else aiPlacement = placement;
              showingAIPlacement = true;
              currentPlacementOwner = "ai";
              powerFill.style.background =
                "linear-gradient(to top, #44aaff, #88e0ff)"; // blue for AI
              powerFill.style.height = Math.round(placement * 100) + "%";
              ballStuckToAI = true;
              setTimeout(() => {
                // AI hit logic
                lastHitterIndex = i;
                const fixedHitSpeed = 4; // Always fixed speed
                let angle = (Math.random() - 0.5) * 0.6; // random angle
                let vx = Math.sin(angle) * Math.abs(fixedHitSpeed);
                let vy = Math.cos(angle) * fixedHitSpeed * (i < 2 ? -1 : 1);
                ball.vx = vx;
                ball.vy = vy;
                ballStuckToAI = false;
                aiChargingPlayer = null;
                aiCharging = false;
                showingAIPlacement = false;
                currentPlacementOwner = null;
                powerFill.style.height = "0%";
                // Set bounceState for indicator
                const bounce = getBounceLocation(
                  player.x,
                  player.y,
                  placement,
                  i < 2,
                  vx,
                  vy
                );
                bounceState = {
                  x: bounce.x,
                  y: bounce.y,
                  shown: false,
                  color: i < 2 ? "#2196F3" : "#E91E63",
                };
                // Alternation logic (advance to next hitter)
                let nextTeam, nextHitter;
                if (i < 2) {
                  // Team 1 hit, so Team 2's turn
                  nextTeam = [2, 3];
                  nextHitter = lastHitter[1] === 2 ? 3 : 2;
                  lastHitter[0] = i;
                } else {
                  // Team 2 hit, so Team 1's turn
                  nextTeam = [0, 1];
                  nextHitter = lastHitter[0] === 0 ? 1 : 0;
                  lastHitter[1] = i;
                }
                allowedHitter = nextHitter;
                hasBouncedSinceLastHit = false;
              }, 400 + Math.random() * 400);
              return;
            }
            // If AI is charging, don't process hit/alternation
            if (!player.isUser && aiCharging) return;
            // --- Alternation and hit logic for user (or AI if not charging) ---
            let nextTeam, nextHitter;
            if (i < 2) {
              // Team 1 hit, so Team 2's turn
              nextTeam = [2, 3];
              nextHitter = lastHitter[1] === 2 ? 3 : 2;
              lastHitter[0] = i;
            } else {
              // Team 2 hit, so Team 1's turn
              nextTeam = [0, 1];
              nextHitter = lastHitter[0] === 0 ? 1 : 0;
              lastHitter[1] = i;
            }
            allowedHitter = nextHitter;
            // Hit the ball
            const angle = Math.atan2(ball.y - player.y, ball.x - player.x);
            const fixedHitSpeed = 4; // Same as serve speed for consistency
            ball.vx = Math.cos(angle) * fixedHitSpeed;
            ball.vy = Math.sin(angle) * fixedHitSpeed;
            if (i === 1) {
              // Randomize teammate placement like AI
              let rand = Math.random();
              if (rand < 0.85) {
                teammatePlacement = 0.5 + Math.random() * 0.4; // 0.5-0.9
              } else {
                teammatePlacement =
                  Math.random() < 0.5
                    ? 0.2 + Math.random() * 0.28
                    : 0.91 + Math.random() * 0.09;
              }
              // Set bounceState for teammate (do NOT show indicator here)
              const bounce = getBounceLocation(
                player.x,
                player.y,
                teammatePlacement,
                false,
                ball.vx,
                ball.vy
              );
              bounceState = {
                x: bounce.x,
                y: bounce.y,
                shown: false,
                color: "#2196F3", // blue for team 1
              };
              // Do NOT trigger bouncePing here; let updateBall handle it
            }
          }
        });
        // After players.forEach, reset aiWaitingForBallToLeave only if the ball is far from all AI paddles
        if (aiWaitingForBallToLeave) {
          let allFar = true;
          for (let j = 0; j < players.length; j++) {
            if (!players[j].isUser) {
              const dist = Math.sqrt(
                (ball.x - players[j].x) ** 2 + (ball.y - players[j].y) ** 2
              );
              if (dist < 44) {
                allFar = false;
                break;
              }
            }
          }
          if (allFar) aiWaitingForBallToLeave = false;
        }

        if (!gameState.isServe && allowedHitter === 0 && !ballStuck) {
          const dist = Math.sqrt(
            (ball.x - players[0].x) ** 2 + (ball.y - players[0].y) ** 2
          );
          if (dist < ball.radius + 30) {
            // Increased stick distance
            ballStuck = true;
            stuckPlayer = 0;
            charging = false;
            chargePower = 0;
            aimArrow.style.display = "none";
            powerFill.style.height = "0%";
            return;
          }
        }
        // While ballStuck, make the ball follow the player
        if (ballStuck && stuckPlayer === 0) {
          ball.x = players[0].x;
          ball.y = players[0].y - 20;
          return;
        }
        // While ballStuckToAI, make the ball follow the AI charging player
        if (ballStuckToAI && aiChargingPlayer !== null) {
          ball.x = players[aiChargingPlayer].x;
          ball.y = players[aiChargingPlayer].y + 20; // stick below AI paddle
          return;
        }

        // At the end of updateBall, after all ball movement and before paddle collision logic:
        if (bounceState && !bounceState.shown) {
          // For user shot, ball moves upward (vy < 0), for AI shot, downward (vy > 0)
          if (
            (ball.vy < 0 && ball.y <= bounceState.y) ||
            (ball.vy > 0 && ball.y >= bounceState.y)
          ) {
            hasBounced = false; // Reset after every bounce so next volley is checked for being wide
            bouncePing = {
              x: bounceState.x,
              y: bounceState.y,
              time: performance.now(),
              color: bounceState.color,
            };
            bounceState.shown = true;
            // --- Diagonal serve enforcement (first bounce after serve) ---
            if (isServeInProgress) {
              isServeInProgress = false;
              const centerX = table.x + table.width / 2;
              const server = gameState.currentServer;
              let correctSide = null;
              // Player 0 and 2: must bounce on right half (x > centerX)
              // Player 1 and 3: must bounce on left half (x < centerX)
              if (server === 0 || server === 2) correctSide = "right";
              else correctSide = "left";
              if (
                (correctSide === "right" && bouncePing.x <= centerX) ||
                (correctSide === "left" && bouncePing.x >= centerX)
              ) {
                // Serve is out, award point to opponent
                let opponentTeam = players[server].team === 1 ? 2 : 1;
                scorePoint(opponentTeam);
                hasBouncedIn = false;
                hasBouncedSinceLastHit = false;
                return;
              }
            }
            // --- Bounce-based out detection ---
            // Determine which team should receive the bounce (who is the opponent?)
            // If last hitter was team 1 (player 0 or 1), bounce must be on team 2's side (top half)
            // If last hitter was team 2 (player 2 or 3), bounce must be on team 1's side (bottom half)
            let lastHitterIdx =
              allowedHitter < 2 ? lastHitter[1] : lastHitter[0];
            let hitterTeam = lastHitterIdx < 2 ? 1 : 2;
            let opponentTeam = hitterTeam === 1 ? 2 : 1;
            // Table bounds
            const left = table.x;
            const right = table.x + table.width;
            const top = table.y;
            const bottom = table.y + table.height;
            // Ball must land on opponent's half (including lines)
            let inBounds = false;
            if (hitterTeam === 1) {
              // Ball must land on top half (team 2's side)
              inBounds =
                bouncePing.x >= left &&
                bouncePing.x <= right &&
                bouncePing.y >= top &&
                bouncePing.y <= table.netY;
            } else {
              // Ball must land on bottom half (team 1's side)
              inBounds =
                bouncePing.x >= left &&
                bouncePing.x <= right &&
                bouncePing.y >= table.netY &&
                bouncePing.y <= bottom;
            }
            if (!inBounds) {
              let lastHitterIdx =
                typeof lastHitterIndex !== "undefined"
                  ? lastHitterIndex
                  : allowedHitter < 2
                  ? lastHitter[1]
                  : lastHitter[0];
              let hitterTeam = lastHitterIdx < 2 ? 1 : 2;
              let opponentTeam = hitterTeam === 1 ? 2 : 1;
              scorePoint(opponentTeam);
              hasBouncedIn = false;
              hasBouncedSinceLastHit = false;
              return;
            } else {
              hasBouncedIn = true; // Only set true if bounce was in
              hasBouncedSinceLastHit = true;
            }
            // --- End bounce-based out detection ---
          }
        }
      }

      function switchHitter() {
        // Doubles rules: alternate within team, then switch teams
        if (gameState.currentHitter === 0) gameState.currentHitter = 2;
        else if (gameState.currentHitter === 2) gameState.currentHitter = 1;
        else if (gameState.currentHitter === 1) gameState.currentHitter = 3;
        else if (gameState.currentHitter === 3) gameState.currentHitter = 0;
      }

      // --- AI LOGIC IMPROVEMENTS ---
      function predictBallLandingX() {
        // Simple prediction: where will the ball cross the AI's y line?
        let t;
        let targetY;
        if (allowedHitter === 2) {
          targetY = players[2].y + 20; // Top AI
          if (ball.vy === 0) return ball.x;
          t = (targetY - ball.y) / ball.vy;
        } else if (allowedHitter === 3) {
          targetY = players[3].y + 20; // Top AI
          if (ball.vy === 0) return ball.x;
          t = (targetY - ball.y) / ball.vy;
        } else {
          return ball.x;
        }
        return ball.x + ball.vx * t;
      }

      function updateAI() {
        // Allow AI opponents to move further outside the table
        const margin = -canvas.width * 0.3;
        [2, 3].forEach((i) => {
          const player = players[i];
          if (i === allowedHitter) {
            // Predict where the ball will cross their y
            const predictedX = Math.max(
              margin,
              Math.min(canvas.width - margin, predictBallLandingX())
            );
            player.targetX = predictedX;
          } else {
            // Default position
            player.targetX = table.x + table.width * (i === 2 ? 0.3 : 0.7);
          }
          player.x += (player.targetX - player.x) * 0.15;
        });
      }

      // Replace AI hit logic in updateBall with robust AI charging/hit gating
      // The AI charging and power meter logic is now handled within the players.forEach loop
      // The alternation and hit logic is also handled within the players.forEach loop

      function updatePlayers() {
        // User movement
        const margin = -canvas.width * 0.3;
        players[0].x += (players[0].targetX - players[0].x) * 0.2;
        // AI teammate (player 1)
        if (ballStuck && stuckPlayer === 0) {
          // AI teammate returns to default position
          players[1].targetX = table.x + table.width * 0.7;
        } else {
          if (allowedHitter === 1 && ball.y > table.netY) {
            // It's their turn, move toward ball
            players[1].targetX = Math.max(
              margin,
              Math.min(canvas.width - margin, ball.x)
            );
          } else {
            // Default position
            players[1].targetX = table.x + table.width * 0.7;
          }
        }
        players[1].x += (players[1].targetX - players[1].x) * 0.1;
      }

      function scorePoint(team) {
        if (team === 1) {
          gameState.score1++;
          document.getElementById("score1").textContent = gameState.score1;
        } else {
          gameState.score2++;
          document.getElementById("score2").textContent = gameState.score2;
        }

        gameState.ballInPlay = false;
        ball.trail = [];

        // Check win condition
        if (gameState.score1 >= 15 || gameState.score2 >= 15) {
          gameState.gameWon = true;
          document.getElementById(
            "gameInfo"
          ).textContent = `Team ${team} Wins!`;
          document.getElementById("instructions").textContent = "Game Over!";
          return;
        }

        // Next serve
        gameState.servesLeft--;
        if (gameState.servesLeft <= 0) {
          serveRotationIndex = (serveRotationIndex + 1) % serveRotation.length;
          gameState.currentServer = serveRotation[serveRotationIndex];
          gameState.servesLeft = 5;
        }

        gameState.currentHitter = gameState.currentServer;
        document.getElementById("gameInfo").textContent = `Serving: Player ${
          gameState.currentServer + 1
        } (Serves left: ${gameState.servesLeft})`;

        // Reset player and ball position for serve
        setTimeout(() => {
          // Designated serve spots (same as in resizeCanvas)
          const serveSpots = [
            {
              x: table.x + table.width * 0.3,
              y: table.y + table.height * 0.94,
            },
            {
              x: table.x + table.width * 0.7,
              y: table.y + table.height * 0.94,
            },
            {
              x: table.x + table.width * 0.3,
              y: table.y + table.height * 0.06,
            },
            {
              x: table.x + table.width * 0.7,
              y: table.y + table.height * 0.06,
            },
          ];
          const server = gameState.currentServer;
          players[server].x = players[server].targetX = serveSpots[server].x;
          players[server].y = serveSpots[server].y;
          // For user, also lock their teammate to default spot
          if (server === 0) {
            players[1].x = players[1].targetX = serveSpots[1].x;
            players[1].y = serveSpots[1].y;
          }
          // For AI, also lock their teammate to default spot
          if (server === 2) {
            players[3].x = players[3].targetX = serveSpots[3].x;
            players[3].y = serveSpots[3].y;
          }
          ball.x = players[server].x;
          // Place ball in front of server (above for top, below for bottom)
          if (server === 0 || server === 1) {
            ball.y = players[server].y - 50;
          } else {
            ball.y = players[server].y + 50;
          }
          ball.vx = 0;
          ball.vy = 0;
          hasBouncedIn = false;
          hasBouncedSinceLastHit = false;

          // If the server is an AI, trigger AI serve after a short delay
          if (server !== 0) {
            setTimeout(() => {
              // AI serve: 85-90% chance of going in on the correct quadrant
              lastHitterIndex = server;
              hasBouncedSinceLastHit = false;
              let placement;
              let rand = Math.random();
              let targetX;
              const centerX = table.x + table.width / 2;
              if (rand < 0.875) {
                // 87.5% chance: serve in, aim for center of correct quadrant
                placement = 0.55 + Math.random() * 0.35; // 0.55-0.9
                // Determine target x for correct quadrant
                if (server === 0 || server === 2) {
                  // Right half
                  targetX =
                    centerX +
                    table.width / 4 +
                    (Math.random() - 0.5) * (table.width / 6);
                } else {
                  // Left half
                  targetX =
                    centerX -
                    table.width / 4 +
                    (Math.random() - 0.5) * (table.width / 6);
                }
              } else {
                // 12.5% chance: serve out (either short or long, random side)
                placement =
                  Math.random() < 0.5
                    ? 0.2 + Math.random() * 0.28
                    : 0.91 + Math.random() * 0.09;
                // Out serves: aim randomly across the table
                targetX = table.x + Math.random() * table.width;
              }
              // Calculate angle to targetX at far end line
              let fromX = players[server].x;
              let fromY = players[server].y;
              let toY =
                server === 0 || server === 1 ? table.y : table.y + table.height;
              let toX = targetX;
              let angle =
                Math.atan2(toY - fromY, toX - fromX) +
                (Math.random() - 0.5) * 0.12;
              const fixedSpeed = 4;
              let vx = Math.cos(angle) * fixedSpeed;
              let vy = Math.sin(angle) * fixedSpeed;
              ball.vx = vx;
              ball.vy = vy;
              gameState.ballInPlay = true;
              // After the serve, set allowedHitter to the diagonal opponent
              const diagonal = [3, 2, 1, 0];
              allowedHitter = diagonal[server];
              gameState.currentHitter = allowedHitter;
              // Set bounce state for AI serve
              const bounce = getBounceLocation(
                players[server].x,
                players[server].y,
                placement,
                server === 0 || server === 1,
                vx,
                vy
              );
              bounceState = {
                x: bounce.x,
                y: bounce.y,
                shown: false,
                color: "#fff",
              };
              hasBouncedIn = false;
            }, 600);
          }

          // In serve reset (setTimeout in scorePoint), set allowedHitter = server (not diagonal opponent):
          allowedHitter = server;
          gameState.currentHitter = server;

          // Set lastHitter so alternation works after the first return
          // Team 1: indices 0,1; Team 2: indices 2,3
          // If server is team 1 (0 or 1), lastHitter = [server, diagonal[server]]
          // If server is team 2 (2 or 3), lastHitter = [diagonal[server], server]
          const diagonal = [3, 2, 1, 0];
          if (server === 0 || server === 1) {
            lastHitter = [server, diagonal[server]];
          } else {
            lastHitter = [diagonal[server], server];
          }

          if (gameState.currentServer === 0) {
            document.getElementById("instructions").textContent =
              "Your serve! Hold to aim & power";
          } else {
            document.getElementById("instructions").textContent =
              "Click/tap to move, hold to aim & power";
          }
        }, 1000);
        lastHitter = [0, 2]; // Reset alternation on point
        allowedHitter = gameState.currentServer;
        ballStuck = false;
        stuckPlayer = null;
        hasBounced = false;
        hasBouncedIn = false;
        isServeInProgress = true;
      }

      function getInputPosition(e) {
        const rect = canvas.getBoundingClientRect();
        if (e.touches) {
          const touch = e.touches[0] || e.changedTouches[0];
          return {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top,
          };
        } else {
          return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top,
          };
        }
      }

      function handleInputStart(e) {
        e.preventDefault();
        const pos = getInputPosition(e);
        if (ballStuck && stuckPlayer === 0 && !charging) {
          inputStart = pos;
          charging = true;
          chargePower = 0;
          aimArrow.style.display = "block";
          return;
        }
        // Prevent user movement before serve if user is server
        if (!gameState.ballInPlay && allowedHitter === 0) {
          // Only allow charging for serve, not movement
          if (!charging) {
            inputStart = pos;
            charging = true;
            chargePower = 0;
            aimArrow.style.display = "block";
          }
          return;
        }
        // Only allow user to move on click/tap (not mousemove)
        const margin = -canvas.width * 0.3;
        if (pos.y > table.netY) {
          players[0].targetX = Math.max(
            margin,
            Math.min(canvas.width - margin, pos.x)
          );
        }
      }

      function handleInputMove(e) {
        if (!charging) {
          // Prevent user movement before serve if user is server
          const pos = getInputPosition(e);
          if (!gameState.ballInPlay && allowedHitter === 0) {
            return;
          }
          // Do NOT move player on mousemove/touchmove anymore
          return;
        }
        e.preventDefault();

        // Only allow aiming if serve or ball is stuck to user
        if (
          !(
            (!gameState.ballInPlay && allowedHitter === 0) ||
            (ballStuck && stuckPlayer === 0)
          )
        ) {
          return;
        }
        // Block user power meter updates if AI is charging
        if (
          aiCharging ||
          showingAIPlacement ||
          (currentPlacementOwner && currentPlacementOwner !== "user")
        )
          return;

        if (ballStuck && stuckPlayer === 0 && charging) {
          const pos = getInputPosition(e);
          const dx = inputStart.x - pos.x;
          const dy = inputStart.y - pos.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          chargePower = Math.min(distance / 100, 1);
          aimAngle = Math.atan2(dy, dx);
          currentPlacementOwner = "user";
          powerFill.style.background =
            "linear-gradient(to top, #ff4444, #ffff44, #44ff44)";
          powerFill.style.height = chargePower * 100 + "%";
          const player = players[0];
          const arrowLength = 40 + chargePower * 60;
          aimArrow.style.left = player.x - 2 + "px";
          aimArrow.style.top = player.y - arrowLength + "px";
          aimArrow.style.height = arrowLength + "px";
          aimArrow.style.transform = `rotate(${aimAngle - Math.PI / 2}rad)`;
          return;
        }

        // Serve aiming
        if (!gameState.ballInPlay && allowedHitter === 0 && charging) {
          const pos = getInputPosition(e);
          const dx = inputStart.x - pos.x; // Reverse direction
          const dy = inputStart.y - pos.y; // Reverse direction
          const distance = Math.sqrt(dx * dx + dy * dy);

          chargePower = Math.min(distance / 100, 1);
          aimAngle = Math.atan2(dy, dx);

          // Update power meter
          currentPlacementOwner = "user";
          powerFill.style.background =
            "linear-gradient(to top, #ff4444, #ffff44, #44ff44)";
          powerFill.style.height = chargePower * 100 + "%";

          // Update aim arrow
          const player = players[0];
          const arrowLength = 40 + chargePower * 60; // Arrow grows with power
          aimArrow.style.display = "block";
          aimArrow.style.left = player.x - 2 + "px";
          aimArrow.style.top = player.y - arrowLength + "px";
          aimArrow.style.height = arrowLength + "px";
          aimArrow.style.transform = `rotate(${aimAngle - Math.PI / 2}rad)`;
        }
      }

      function handleInputEnd(e) {
        // Only allow hitting if serve or ball is stuck to user
        if (
          !(
            (!gameState.ballInPlay && allowedHitter === 0) ||
            (ballStuck && stuckPlayer === 0)
          )
        ) {
          charging = false;
          if (
            !showingAIPlacement &&
            (!currentPlacementOwner || currentPlacementOwner === "user")
          ) {
            aimArrow.style.display = "none";
            powerFill.style.height = "0%";
            currentPlacementOwner = null;
          }
          return;
        }

        if (ballStuck && stuckPlayer === 0 && charging) {
          charging = false;
          aimArrow.style.display = "none";
          if (
            !showingAIPlacement &&
            (!currentPlacementOwner || currentPlacementOwner === "user")
          ) {
            powerFill.style.height = "0%";
            currentPlacementOwner = null;
          }
          // Hit the ball
          lastHitterIndex = 0; // User is always player 0
          hasBouncedSinceLastHit = false;
          const fixedSpeed = 4;
          ball.vx = Math.cos(aimAngle) * fixedSpeed;
          ball.vy = Math.sin(aimAngle) * fixedSpeed;
          ballStuck = false;
          stuckPlayer = null;
          // Set bounce state for user shot
          const bounce = getBounceLocation(
            players[0].x,
            players[0].y,
            chargePower,
            true,
            ball.vx,
            ball.vy
          );
          bounceState = {
            x: bounce.x,
            y: bounce.y,
            shown: false,
            color: "#fff",
          };
          hasBouncedIn = false;
          return;
        }
        if (!charging) return;
        e.preventDefault();
        charging = false;
        aimArrow.style.display = "none";
        if (
          !showingAIPlacement &&
          (!currentPlacementOwner || currentPlacementOwner === "user")
        ) {
          powerFill.style.height = "0%";
          currentPlacementOwner = null;
        }

        if (chargePower > 0.1) {
          // Serve or hit the ball
          lastHitterIndex = 0; // User is always player 0
          hasBouncedSinceLastHit = false;
          const fixedSpeed = 4; // Stronger serve
          ball.vx = Math.cos(aimAngle) * fixedSpeed;
          ball.vy = Math.sin(aimAngle) * fixedSpeed;
          gameState.ballInPlay = true;

          if (gameState.currentHitter === gameState.currentServer) {
            // Set allowedHitter to diagonal opponent after serve
            // 0â†’3, 1â†’2, 2â†’1, 3â†’0
            const diagonal = [3, 2, 1, 0];
            allowedHitter = diagonal[gameState.currentServer];
            gameState.currentHitter = allowedHitter;
          }
          // Set bounce state for user serve
          const bounce = getBounceLocation(
            players[0].x,
            players[0].y,
            chargePower,
            true,
            ball.vx,
            ball.vy
          );
          bounceState = {
            x: bounce.x,
            y: bounce.y,
            shown: false,
            color: "#fff",
          };
        }
      }

      // Add this helper function at the top level, after other helpers
      function getBounceLocation(
        fromX,
        fromY,
        placement,
        isUser,
        vx = 0,
        vy = 0
      ) {
        // Linear interpolation from hitter's paddle to far end line
        let startY = fromY;
        let endY = isUser ? table.y : table.y + table.height;
        // Clamp placement between 0 and 1
        placement = Math.max(0, Math.min(1, placement));
        // Bounce location is a linear interpolation
        const targetY = startY + (endY - startY) * placement;

        // Calculate the predicted x-coordinate where the ball will land
        // This is a simplified prediction based on current velocity and placement
        // A more accurate prediction would involve physics simulation
        let predictedX = fromX;
        if (vy !== 0) {
          // Predict where the ball will cross the targetY line
          const t = (targetY - fromY) / vy;
          predictedX = fromX + vx * t;
        } else {
          // If vy is 0, the ball is moving horizontally.
          // The bounce will happen at the targetY line.
          predictedX = fromX;
        }

        return { x: predictedX, y: targetY };
      }

      // Event listeners for both touch and mouse
      canvas.addEventListener("touchstart", handleInputStart);
      canvas.addEventListener("touchmove", handleInputMove);
      window.addEventListener("touchend", handleInputEnd);
      canvas.addEventListener("mousedown", handleInputStart);
      canvas.addEventListener("mousemove", handleInputMove);
      window.addEventListener("mouseup", handleInputEnd);

      // Prevent context menu on right click
      canvas.addEventListener("contextmenu", (e) => e.preventDefault());

      // Game loop
      function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawTable();
        updatePlayers(); // Call updatePlayers here
        drawPlayers();
        drawBall();

        if (!gameState.gameWon) {
          updateBall();
          updateAI();
        }

        requestAnimationFrame(gameLoop);
      }

      // Initialize and start game
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);
      isServeInProgress = true;
      gameLoop();

      // Start message
      setTimeout(() => {
        document.getElementById("instructions").textContent =
          "Your serve! Click/tap and hold to aim & power";
      }, 500);
    </script>
  </body>
</html>
