<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Doubles Ping Pong</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #385535;
        font-family: Arial, sans-serif;
        overflow: hidden;
        user-select: none;
      }

      #gameCanvas {
        display: block;
        background: #2d5a2d;
        border: 2px solid #fff;
        cursor: crosshair;
      }

      #topBar {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 64px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        z-index: 200;
        background: none;
        pointer-events: none;
      }
      #logo {
        height: 54px;
        margin-left: 16px;
        margin-top: 4px;
        pointer-events: auto;
      }
      #scoreBar {
        flex: 1;
        text-align: center;
        font-size: 2rem;
        font-weight: bold;
        letter-spacing: 2px;
        pointer-events: auto;
      }
      .score {
        padding: 0 12px;
        font-size: 2.1rem;
        vertical-align: middle;
      }
      .score.blue {
        color: #2196f3;
        text-shadow: 0 0 8px #2196f3cc;
      }
      .score.red {
        color: #f44336;
        text-shadow: 0 0 8px #f44336cc;
      }
      .score-separator {
        color: #fff;
        font-size: 2rem;
        padding: 0 8px;
      }
      #menuBtn {
        background: none;
        border: none;
        color: #fff;
        font-size: 2.4rem;
        margin-right: 18px;
        margin-top: 2px;
        cursor: pointer;
        z-index: 201;
        pointer-events: auto;
        filter: drop-shadow(0 0 4px #000a);
        transition: color 0.2s;
      }
      #menuBtn:hover {
        color: #888;
      }
      #bottomBar {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 54px;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 200;
        pointer-events: none;
      }
      #gameInfo {
        color: #fff;
        font-size: 1.1rem;
        background: rgba(0, 0, 0, 0.32);
        border-radius: 12px;
        padding: 6px 22px;
        box-shadow: 0 2px 12px #0006;
        pointer-events: auto;
      }

      #powerMeter {
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        width: 30px;
        height: 200px;
        background: rgba(255, 255, 255, 0.3);
        border: 2px solid white;
        border-radius: 15px;
        z-index: 100;
        overflow: hidden;
      }

      #powerFill {
        position: absolute;
        bottom: 0;
        width: 100%;
        background: linear-gradient(to top, #ff4444, #ffff44, #44ff44);
        border-radius: 0 0 13px 13px;
        transition: height 0.1s;
      }

      #aimArrow {
        position: absolute;
        width: 4px;
        background: #ffff44;
        transform-origin: bottom center;
        z-index: 100;
        display: none;
      }

      #controls {
        display: none;
      }
      /* Pulse animation for win message */
      @keyframes pulseWin {
        0% {
          transform: scale(1);
          filter: brightness(1);
        }
        50% {
          transform: scale(1.12);
          filter: brightness(1.5);
        }
        100% {
          transform: scale(1);
          filter: brightness(1);
        }
      }
      .winPulse {
        animation: pulseWin 1.1s infinite;
        font-weight: bold;
        letter-spacing: 2px;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>
    <div id="topBar">
      <img id="logo" src="lob-pong-logo.png" alt="Lob Pong Logo" />
      <div id="scoreBar">
        <span id="score1" class="score blue">0</span>
        <span class="score-separator">|</span>
        <span id="score2" class="score red">0</span>
      </div>
      <button id="menuBtn" aria-label="Menu">&#9776;</button>
    </div>

    <div id="powerMeter">
      <div id="powerFill"></div>
    </div>

    <div id="aimArrow"></div>

    <div id="bottomBar">
      <div id="gameInfo">Serving: Player 1</div>
    </div>

    <!-- Start New Game button, hidden by default -->
    <button
      id="newGameBtn"
      style="
        display: none;
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        z-index: 300;
        font-size: 2rem;
        padding: 18px 48px;
        border-radius: 18px;
        border: none;
        background: #222;
        color: #fff;
        box-shadow: 0 4px 24px #0008;
        cursor: pointer;
        font-weight: bold;
      "
    >
      Start New Game
    </button>

    <!-- Menu Modal -->
    <div
      id="menuModal"
      style="
        display: none;
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        height: 66vh;
        background: #385535;
        border-top-left-radius: 32px;
        border-top-right-radius: 32px;
        z-index: 500;
        box-shadow: 0 -8px 32px #000a;
        margin: 0;
        padding: 0;
        overflow-y: auto;
        transition: transform 0.3s cubic-bezier(0.4, 1.4, 0.6, 1);
        display: flex;
        flex-direction: column;
        align-items: center;
      "
    >
      <div
        style="
          width: 100%;
          max-width: 600px;
          padding: 0 20px 24px 20px;
          box-sizing: border-box;
          margin: 0 auto;
        "
      >
        <div
          style="
            position: sticky;
            top: 0;
            z-index: 20;
            background: #385535;
            border-top-left-radius: 32px;
            border-top-right-radius: 32px;
            padding: 32px 24px 0 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 64px;
          "
        >
          <h2
            style="
              color: #fff;
              margin: 0 auto 0 auto;
              text-align: center;
              letter-spacing: 2px;
              flex: 1;
              font-size: 2rem;
            "
          >
            Menu
          </h2>
          <button
            id="closeMenuBtn"
            style="
              position: absolute;
              top: 18px;
              right: 18px;
              background: #222;
              color: #fff;
              border: none;
              border-radius: 50%;
              width: 38px;
              height: 38px;
              font-size: 1.5rem;
              cursor: pointer;
              z-index: 10;
            "
          >
            &times;
          </button>
        </div>
        <div
          id="controlsSection"
          style="
            background: #46643e;
            border-radius: 18px;
            padding: 18px 16px;
            margin: 24px 0 24px 0;
            cursor: pointer;
          "
        >
          <h3 style="color: #fff; margin: 0 0 8px 0; font-size: 1.2rem">
            Game Controls
          </h3>
          <p
            id="controlsToggleMsg"
            style="color: #e0e0e0; margin: 0; font-size: 1rem"
          >
            Click to view controls
          </p>
          <ul
            id="controlsList"
            style="
              display: none;
              color: #e0e0e0;
              margin: 0;
              font-size: 1rem;
              padding-left: 20px;
            "
          >
            <li>
              <b>Desktop:</b> Click/tap to move. Hold and drag to aim and charge
              your shot. Release to hit.
            </li>
            <li>
              <b>Mobile:</b> Tap to move. Hold and drag to aim and charge your
              shot. Release to hit.
            </li>
            <li>Menu: Top-right button (pauses game)</li>
          </ul>
        </div>
        <div
          id="rulesSection"
          style="
            background: #46643e;
            border-radius: 18px;
            padding: 18px 16px;
            margin-bottom: 24px;
            cursor: pointer;
          "
        >
          <h3 style="color: #fff; margin: 0 0 8px 0; font-size: 1.2rem">
            Lob Pong Rules
          </h3>
          <p style="color: #e0e0e0; margin: 0; font-size: 1rem">
            Click to view rules
          </p>
        </div>
        <div
          id="rulesModal"
          style="
            display: none;
            background: #2d3e25;
            border-radius: 16px;
            padding: 18px 16px;
            margin-bottom: 24px;
            color: #fff;
            font-size: 1.05rem;
          "
        >
          <h3 style="margin-top: 0; margin-bottom: 12px; color: #f7e14a">
            Lob Pong Rules
          </h3>
          <ul style="padding-left: 20px; margin: 0">
            <li>Play to 15 points (must win by 2)</li>
            <li>
              The ball must always clear the bar on serves and during play
            </li>
            <li>
              5 serves per player before switching to a player on the other team
              to serve 5 times
            </li>
            <li>Serve diagonally</li>
            <li>
              During gameplay, teammates must alternate turns (i.e. the same
              player cannot hit the ball two turns in a row for their team)
            </li>
            <li>
              If the ball hits a cup, play can continue as long as the ball has
              only hit the table once
            </li>
            <li>
              If the ball goes in a cup, PARTY! Also the team that made it gets
              a point ;)
            </li>
          </ul>
        </div>
        <button
          id="restartBtn"
          style="
            width: 100%;
            background: #222;
            color: #fff;
            font-size: 1.1rem;
            border: none;
            border-radius: 12px;
            padding: 14px 0;
            margin-bottom: 18px;
            cursor: pointer;
          "
        >
          Restart New Game
        </button>
        <button
          id="buyBtn"
          style="
            width: 100%;
            background: #f7e14a;
            color: #222;
            font-size: 1.1rem;
            border: none;
            border-radius: 12px;
            padding: 14px 0;
            margin-bottom: 0;
            cursor: pointer;
            font-weight: bold;
          "
        >
          BUY REAL Lob Pong set!
        </button>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const powerFill = document.getElementById("powerFill");
      const aimArrow = document.getElementById("aimArrow");

      // Game state
      let gameState = {
        score1: 0,
        score2: 0,
        currentServer: 0,
        servesLeft: 5,
        currentHitter: 0,
        ballInPlay: false,
        gameWon: false,
      };

      // Add at the top, after gameState:
      let lastHitter = [0, 2]; // [team1Last, team2Last]
      let allowedHitter = 0; // index of player allowed to hit next
      let ballStuck = false;
      let stuckPlayer = null;
      // Add at the top, after input handling
      let aiPlacement = 0; // Current AI placement for UI
      let aiPlacementTimeout = null;
      let showingAIPlacement = false;
      let currentPlacementOwner = null; // 'user' or 'ai'
      let aiCharging = false; // AI is preparing to hit
      let aiWaitingForBallToLeave = false; // Prevents retriggering AI charge until ball leaves zone
      let aiChargingPlayer = null; // Which AI is charging (2 or 3)
      let ballStuckToAI = false;
      let lastAIHitter = null; // Track last AI who hit
      // Bounce ping animation state
      let bouncePing = null; // {x, y, time, color}
      let bounceState = null; // {y, shown, color}
      let teammatePlacement = 0;
      let hasBounced = false;
      let hasBouncedIn = false;
      // Add at the top, after other global variables:
      let aimingArrowState = {
        x: 0,
        y: 0,
        angle: 0,
        length: 0,
        visible: false,
      };
      let hasBouncedSinceLastHit = false;
      let isServeInProgress = false;
      // Add at the top, after other global variables:
      // Ball flight arc tracking for net-peak shadow
      let flightStartY = null;
      let flightEndY = null;
      let flightActive = false;
      // At the top, after other global variables:
      let awaitingServeReturn = false;
      // Game objects - initialize with default values
      let table = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        netY: 0,
      };

      let ball = {
        x: 0,
        y: 0,
        vx: 0,
        vy: 0,
        radius: 8,
        trail: [],
      };

      let players = [
        { x: 0, y: 0, targetX: 0, isUser: true, team: 1 },
        { x: 0, y: 0, targetX: 0, isUser: false, team: 1 },
        { x: 0, y: 0, targetX: 0, isUser: false, team: 2 },
        { x: 0, y: 0, targetX: 0, isUser: false, team: 2 },
      ];

      // Input handling
      let inputStart = null;
      let charging = false;
      let chargePower = 0;
      let aimAngle = 0;

      // At the top, define the serve rotation order:
      const serveRotation = [0, 3, 1, 2]; // Player indices: 1, 4, 2, 3
      let serveRotationIndex = 0;

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Maintain 1.8:1 aspect ratio (portrait: height:width)
        const aspect = 1.8;
        let maxTableHeight = window.innerHeight * 0.7; // Reduce from 0.8 to 0.7
        let maxTableWidth = window.innerWidth * 0.9;
        let tableHeight = maxTableHeight;
        let tableWidth = tableHeight / aspect;
        if (tableWidth > maxTableWidth) {
          tableWidth = maxTableWidth;
          tableHeight = tableWidth * aspect;
        }
        table.width = tableWidth;
        table.height = tableHeight;
        table.x = (canvas.width - table.width) / 2;
        table.y = (canvas.height - table.height) / 2;
        table.netY = table.y + table.height / 2;

        // Position players (move further back, 6% gap from end lines)
        players[0].x = players[0].targetX = table.x + table.width * 0.3;
        players[0].y = table.y + table.height * 0.94;
        players[1].x = players[1].targetX = table.x + table.width * 0.7;
        players[1].y = table.y + table.height * 0.94;
        players[2].x = players[2].targetX = table.x + table.width * 0.3;
        players[2].y = table.y + table.height * 0.06;
        players[3].x = players[3].targetX = table.x + table.width * 0.7;
        players[3].y = table.y + table.height * 0.06;

        // Position ball
        ball.x = players[gameState.currentServer].x;
        ball.y = players[gameState.currentServer].y - 50; // Start further from player

        // In resizeCanvas, after setting currentServer:
        allowedHitter = gameState.currentServer;
        lastHitter = [0, 2];
      }

      function drawTable() {
        const sideHeight = 10;

        // 1. Draw the back right leg FIRST
        ctx.fillStyle = "#333";
        const legWidth = 9;
        const legHeight = 50;
        const backRightLegX = table.x + table.width + 2;
        const backRightLegY = table.y + sideHeight + 18;
        const backRightLegAngle = -0.15;
        function drawLeg(x, y, angle, height = legHeight) {
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.rect(0, 0, legWidth, height - 5);
          ctx.arc(legWidth / 2, height - 5, legWidth / 2, 0, Math.PI, false);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        drawLeg(backRightLegX, backRightLegY, backRightLegAngle, legHeight);

        // 2. Draw the right side polygon (this will cover the top of the leg)
        ctx.fillStyle = "#1a3d1a";
        ctx.beginPath();
        ctx.moveTo(table.x + table.width + 3, table.y); // top right of table
        ctx.lineTo(table.x + table.width + sideHeight, table.y + sideHeight); // bevel
        ctx.lineTo(
          table.x + table.width + sideHeight,
          table.y + table.height + sideHeight
        );
        ctx.lineTo(table.x + table.width - 8, table.y + table.height);
        ctx.lineTo(table.x + table.width, table.y + table.height);
        ctx.closePath();
        ctx.fill();

        // 3. Table shadow (subtle, rectangular, slightly offset)
        ctx.save();
        ctx.globalAlpha = 0.13;
        ctx.fillStyle = "#000";
        ctx.fillRect(
          table.x + 8,
          table.y + table.height + sideHeight + 4,
          table.width - 16,
          14
        );
        ctx.restore();

        // 4. Draw the other legs (front left, front right)
        ctx.fillStyle = "#333";
        const legAngle = -0.18;
        drawLeg(
          table.x + 16,
          table.y + table.height + sideHeight,
          legAngle,
          32
        );
        drawLeg(
          table.x + table.width - 16 - legWidth,
          table.y + table.height + sideHeight,
          legAngle,
          32
        );

        // 5. Draw the front side polygon
        ctx.fillStyle = "#1a3d1a";
        ctx.beginPath();
        ctx.moveTo(table.x, table.y + table.height);
        ctx.lineTo(table.x + table.width - 8, table.y + table.height);
        ctx.lineTo(
          table.x + table.width + sideHeight,
          table.y + table.height + sideHeight
        );
        ctx.lineTo(table.x + 8, table.y + table.height + sideHeight);
        ctx.closePath();
        ctx.fill();

        // 6. Table top (drawn after sides)
        ctx.fillStyle = "#0d4d0d";
        ctx.fillRect(table.x, table.y, table.width, table.height);

        // 7. Table border
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 4;
        ctx.strokeRect(table.x, table.y, table.width, table.height);

        // Net
        ctx.fillStyle = "#fff";
        ctx.fillRect(table.x, table.netY - 3, table.width, 6);

        // Center line
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(table.x + table.width / 2, table.y);
        ctx.lineTo(table.x + table.width / 2, table.netY - 3);
        ctx.moveTo(table.x + table.width / 2, table.netY + 3);
        ctx.lineTo(table.x + table.width / 2, table.y + table.height);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw bounce ping animation if active
        if (bouncePing) {
          const elapsed = performance.now() - bouncePing.time;
          if (elapsed < 900) {
            const maxRadius = 20;
            const minRadius = 6;
            const radius =
              minRadius + (maxRadius - minRadius) * (elapsed / 900);
            ctx.save();
            ctx.globalAlpha = 0.5 * (1 - elapsed / 900) + 0.3;
            ctx.beginPath();
            ctx.arc(bouncePing.x, bouncePing.y, radius, 0, Math.PI * 2);
            ctx.fillStyle = "#eee8";
            ctx.fill();
            ctx.globalAlpha = 1 - elapsed / 900;
            ctx.lineWidth = 5;
            ctx.strokeStyle = "#eee";
            ctx.shadowColor = "#eee";
            ctx.shadowBlur = 18;
            ctx.stroke();
            ctx.restore();
          } else {
            bouncePing = null;
          }
        }
      }

      function drawPlayers() {
        players.forEach((player, i) => {
          ctx.save();
          // If waiting for serve, highlight the server
          if (!gameState.ballInPlay && i === gameState.currentServer) {
            ctx.globalAlpha = 1;
          } else if (i !== allowedHitter) {
            ctx.globalAlpha = 0.3; // Dim everyone except allowedHitter
          } else {
            ctx.globalAlpha = 1;
          }
          // Player paddle: both team 1 (0,1) are blue, team 2 (2,3) are red
          ctx.fillStyle = player.team === 1 ? "#2196F3" : "#F44336";
          ctx.beginPath();
          ctx.arc(player.x, player.y, 18, 0, Math.PI * 2);
          ctx.fill();

          // Neon blue border for user (player 0), dims with player, no shadow for mobile compatibility
          if (i === 0) {
            ctx.save();
            ctx.lineWidth = 4;
            ctx.strokeStyle = "#00e6ff";
            ctx.beginPath();
            ctx.arc(player.x, player.y, 20, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          }

          // Player number
          ctx.fillStyle = "#fff";
          ctx.font = "bold 14px Arial";
          ctx.textAlign = "center";
          ctx.fillText(i + 1, player.x, player.y + 5);

          ctx.restore();
        });
      }

      function drawBall() {
        if (ball.trail.length > 1) {
          // Ball trail
          ctx.strokeStyle = "rgba(255,255,255,0.5)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          for (let i = 0; i < ball.trail.length - 1; i++) {
            const alpha = i / ball.trail.length;
            ctx.globalAlpha = alpha;
            ctx.moveTo(ball.trail[i].x, ball.trail[i].y);
            ctx.lineTo(ball.trail[i + 1].x, ball.trail[i + 1].y);
          }
          ctx.stroke();
          ctx.globalAlpha = 1;
        }

        // --- Net-peak dynamic shadow and ball height ---
        let t = 0;
        if (
          flightActive &&
          flightStartY !== null &&
          flightEndY !== null &&
          flightStartY !== flightEndY
        ) {
          t = (ball.y - flightStartY) / (flightEndY - flightStartY);
          t = Math.max(0, Math.min(1, t));
        }
        // Height: 0 at t=0/1, max at t=0.5 (net)
        let height = 1 - 4 * Math.pow(t - 0.5, 2);
        height = Math.max(0, height);
        let visualHeight = Math.pow(height, 1.7);
        let shadowAlpha = 0.16 + 0.28 * (1 - visualHeight);
        let shadowRadiusX = ball.radius * (1.18 - 0.5 * visualHeight);
        let shadowRadiusY = ball.radius * (0.48 - 0.12 * visualHeight);
        let shadowYOffset = ball.radius + 3 + 13 * visualHeight;
        let ballScale = 1 - 0.16 * visualHeight;
        // Draw shadow
        ctx.save();
        ctx.globalAlpha = shadowAlpha;
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.ellipse(
          ball.x,
          ball.y + shadowYOffset,
          shadowRadiusX,
          shadowRadiusY,
          0,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.restore();
        // Draw ball
        ctx.save();
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#ccc";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius * ballScale, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }

      function updateBall() {
        if (!gameState.ballInPlay) return;

        // Update trail
        ball.trail.push({ x: ball.x, y: ball.y });
        if (ball.trail.length > 10) ball.trail.shift();

        // On hit, record flight start/end Y for net-peak arc
        if (ballStuck || ballStuckToAI) {
          flightActive = false;
          flightStartY = null;
          flightEndY = null;
        } else if (
          !flightActive &&
          (Math.abs(ball.vx) > 0 || Math.abs(ball.vy) > 0)
        ) {
          flightStartY = ball.y;
          // Use bounceState.y if available, else far end of table
          if (bounceState && typeof bounceState.y === "number") {
            flightEndY = bounceState.y;
          } else {
            flightEndY = ball.vy < 0 ? table.y : table.y + table.height;
          }
          flightActive = true;
        }

        ball.x += ball.vx;
        ball.y += ball.vy;

        // Ball physics (top-down view: no gravity)
        // ball.vx *= 0.95; // Stronger friction
        // ball.vy *= 0.95;

        // --- Out on volley wide ---
        const left = table.x;
        const right = table.x + table.width;
        const margin = 20;
        if (
          ball.x < margin ||
          ball.x > canvas.width - margin ||
          ball.y < table.y ||
          ball.y > table.y + table.height
        ) {
          // If awaiting serve return, point goes to server
          if (awaitingServeReturn) {
            let serverTeam = players[gameState.currentServer].team;
            scorePoint(serverTeam);
            awaitingServeReturn = false;
            return;
          } else {
            // Rally logic: if the ball bounced in before going out, point to last hitter; otherwise, to opponent
            if (hasBouncedSinceLastHit) {
              const teamToScore = players[lastHitterIndex].team;
              scorePoint(teamToScore);
            } else {
              let hitterTeam = players[lastHitterIndex].team;
              let opponentTeam = hitterTeam === 1 ? 2 : 1;
              scorePoint(opponentTeam);
            }
            return;
          }
        }

        // Check paddle collisions
        players.forEach((player, i) => {
          if (i !== allowedHitter) return;
          const dist = Math.sqrt(
            (ball.x - player.x) ** 2 + (ball.y - player.y) ** 2
          );
          // Prevent hitting a ball that never bounced in and is wide
          if (
            !hasBouncedSinceLastHit &&
            (ball.x < table.x || ball.x > table.x + table.width)
          ) {
            return; // Do not allow the hit, let the ball visually continue
          }
          if (dist < (player.isUser ? ball.radius + 18 : 40)) {
            lastHitterIndex = i;
            // After a valid hit, if awaitingServeReturn is true, set it to false
            if (awaitingServeReturn) {
              awaitingServeReturn = false;
            }
            // --- Diagonal serve enforcement on paddle collision (for full power serves) ---
            if (isServeInProgress) {
              const centerX = table.x + table.width / 2;
              const server = gameState.currentServer;
              let correctSide = null;
              // Player 0 and 2: must serve to right half (x > centerX)
              // Player 1 and 3: must serve to left half (x < centerX)
              if (server === 0 || server === 2) correctSide = "right";
              else correctSide = "left";
              if (
                (correctSide === "right" && ball.x <= centerX) ||
                (correctSide === "left" && ball.x >= centerX)
              ) {
                // Serve is out, award point to opponent
                isServeInProgress = false;
                let opponentTeam = players[server].team === 1 ? 2 : 1;
                scorePoint(opponentTeam);
                hasBouncedIn = false;
                hasBouncedSinceLastHit = false;
                awaitingServeReturn = false;
                return;
              } else if (ball.x < table.x || ball.x > table.x + table.width) {
                // Serve is wide, out
                isServeInProgress = false;
                let opponentTeam = players[server].team === 1 ? 2 : 1;
                scorePoint(opponentTeam);
                hasBouncedIn = false;
                hasBouncedSinceLastHit = false;
                awaitingServeReturn = false;
                return;
              } else {
                // Serve is in, allow regular gameplay
                isServeInProgress = false;
                hasBouncedIn = true;
                hasBouncedSinceLastHit = false;
                // Do not return; allow normal hit logic to proceed
              }
            }
            // Before setting a new bounceState, show the previous one if not yet shown
            if (bounceState && !bounceState.shown) {
              bouncePing = {
                x: ball.x,
                y: ball.y,
                time: performance.now(),
                color: bounceState.color,
              };
              bounceState.shown = true;
            }
            // For AI teammates and opponents (players 1, 2, 3)
            if (!player.isUser && !aiCharging && aiChargingPlayer === null) {
              aiCharging = true;
              aiChargingPlayer = i;
              let rand = Math.random();
              let placement;
              if (rand < 0.85) {
                placement = 0.5 + Math.random() * 0.4; // 0.5-0.9
              } else {
                placement =
                  Math.random() < 0.5
                    ? 0.2 + Math.random() * 0.28
                    : 0.91 + Math.random() * 0.09;
              }
              if (i === 1) teammatePlacement = placement;
              else aiPlacement = placement;
              showingAIPlacement = true;
              currentPlacementOwner = "ai";
              powerFill.style.background =
                "linear-gradient(to top, #44aaff, #88e0ff)"; // blue for AI
              powerFill.style.height = Math.round(placement * 100) + "%";
              ballStuckToAI = true;
              setTimeout(() => {
                lastHitterIndex = i; // Ensure lastHitterIndex is always set for every AI hit
                const fixedHitSpeed = 4; // Always fixed speed
                let angle = (Math.random() - 0.5) * 0.6; // random angle
                let vx = Math.sin(angle) * Math.abs(fixedHitSpeed);
                let vy = Math.cos(angle) * fixedHitSpeed * (i < 2 ? -1 : 1);
                ball.vx = vx;
                ball.vy = vy;
                ballStuckToAI = false;
                aiChargingPlayer = null;
                aiCharging = false;
                showingAIPlacement = false;
                currentPlacementOwner = null;
                powerFill.style.height = "0%";
                // Set bounceState for indicator
                const bounce = getBounceLocation(
                  player.x,
                  player.y,
                  placement,
                  i < 2,
                  vx,
                  vy
                );
                bounceState = {
                  x: bounce.x,
                  y: bounce.y,
                  shown: false,
                  color: i < 2 ? "#2196F3" : "#E91E63",
                };
                // Alternation logic (advance to next hitter)
                let nextTeam, nextHitter;
                if (i < 2) {
                  // Team 1 hit, so Team 2's turn
                  nextTeam = [2, 3];
                  nextHitter = lastHitter[1] === 2 ? 3 : 2;
                  lastHitter[0] = i;
                } else {
                  // Team 2 hit, so Team 1's turn
                  nextTeam = [0, 1];
                  nextHitter = lastHitter[0] === 0 ? 1 : 0;
                  lastHitter[1] = i;
                }
                allowedHitter = nextHitter;
                hasBouncedSinceLastHit = false;
              }, 400 + Math.random() * 400);
              return;
            }
            // If AI is charging, don't process hit/alternation
            if (!player.isUser && aiCharging) return;
            // --- Alternation and hit logic for user (or AI if not charging) ---
            let nextTeam, nextHitter;
            if (i < 2) {
              // Team 1 hit, so Team 2's turn
              nextTeam = [2, 3];
              nextHitter = lastHitter[1] === 2 ? 3 : 2;
              lastHitter[0] = i;
            } else {
              // Team 2 hit, so Team 1's turn
              nextTeam = [0, 1];
              nextHitter = lastHitter[0] === 0 ? 1 : 0;
              lastHitter[1] = i;
            }
            allowedHitter = nextHitter;
            // Hit the ball
            const angle = Math.atan2(ball.y - player.y, ball.x - player.x);
            const fixedHitSpeed = 4; // Same as serve speed for consistency
            ball.vx = Math.cos(angle) * fixedHitSpeed;
            ball.vy = Math.sin(angle) * fixedHitSpeed;
            hasBouncedSinceLastHit = false;
            // If this is the first return after a valid serve, set awaitingServeReturn to false
            if (awaitingServeReturn) {
              awaitingServeReturn = false;
            }
            if (i === 1) {
              // Randomize teammate placement like AI
              let rand = Math.random();
              if (rand < 0.85) {
                teammatePlacement = 0.5 + Math.random() * 0.4; // 0.5-0.9
              } else {
                teammatePlacement =
                  Math.random() < 0.5
                    ? 0.2 + Math.random() * 0.28
                    : 0.91 + Math.random() * 0.09;
              }
              // Set bounceState for teammate (do NOT show indicator here)
              const bounce = getBounceLocation(
                player.x,
                player.y,
                teammatePlacement,
                false,
                ball.vx,
                ball.vy
              );
              bounceState = {
                x: bounce.x,
                y: bounce.y,
                shown: false,
                color: "#2196F3", // blue for team 1
              };
              // Do NOT trigger bouncePing here; let updateBall handle it
            }
          }
        });
        // After players.forEach, reset aiWaitingForBallToLeave only if the ball is far from all AI paddles
        if (aiWaitingForBallToLeave) {
          let allFar = true;
          for (let j = 0; j < players.length; j++) {
            if (!players[j].isUser) {
              const dist = Math.sqrt(
                (ball.x - players[j].x) ** 2 + (ball.y - players[j].y) ** 2
              );
              if (dist < 44) {
                allFar = false;
                break;
              }
            }
          }
          if (allFar) aiWaitingForBallToLeave = false;
        }

        if (!gameState.isServe && allowedHitter === 0 && !ballStuck) {
          // Only allow sticking if the ball has bounced since last hit, or is within the table width
          if (
            hasBouncedSinceLastHit ||
            (ball.x >= table.x && ball.x <= table.x + table.width)
          ) {
            const dist = Math.sqrt(
              (ball.x - players[0].x) ** 2 + (ball.y - players[0].y) ** 2
            );
            if (dist < ball.radius + 30) {
              // Increased stick distance
              ballStuck = true;
              stuckPlayer = 0;
              charging = false;
              powerFill.style.height = "0%";
              return;
            }
          }
        }
        // While ballStuck, make the ball follow the player
        if (ballStuck && stuckPlayer === 0) {
          ball.x = players[0].x;
          ball.y = players[0].y - 20;
          return;
        }
        // While ballStuckToAI, make the ball follow the AI charging player
        if (ballStuckToAI && aiChargingPlayer !== null) {
          ball.x = players[aiChargingPlayer].x;
          // For player[1] (bottom right, UI player 2), stick above paddle (toward net)
          if (aiChargingPlayer === 1) {
            ball.y = players[1].y - 20;
          } else {
            // For top-side AIs (players 2 and 3), stick below paddle (toward net for their side)
            ball.y = players[aiChargingPlayer].y + 20;
          }
          return;
        }

        // At the end of updateBall, after all ball movement and before paddle collision logic:
        if (bounceState && !bounceState.shown) {
          // For user shot, ball moves upward (vy < 0), for AI shot, downward (vy > 0)
          if (
            (ball.vy < 0 && ball.y <= bounceState.y) ||
            (ball.vy > 0 && ball.y >= bounceState.y)
          ) {
            // Ball bounces: reset flight arc
            flightActive = false;
            flightStartY = null;
            flightEndY = null;
            hasBounced = false; // Reset after every bounce so next volley is checked for being wide
            bouncePing = {
              x: bounceState.x,
              y: bounceState.y,
              time: performance.now(),
              color: bounceState.color,
            };
            bounceState.shown = true;
            hasBouncedSinceLastHit = true;
            // --- Diagonal serve enforcement (first bounce after serve) ---
            if (isServeInProgress) {
              isServeInProgress = false;
              const centerX = table.x + table.width / 2;
              const server = gameState.currentServer;
              let correctSide = null;
              // Player 0 and 2: must bounce on right half (x > centerX)
              // Player 1 and 3: must bounce on left half (x < centerX)
              if (server === 0 || server === 2) correctSide = "right";
              else correctSide = "left";
              if (
                (correctSide === "right" && bouncePing.x <= centerX) ||
                (correctSide === "left" && bouncePing.x >= centerX)
              ) {
                // Serve is out, award point to opponent
                let opponentTeam = players[server].team === 1 ? 2 : 1;
                scorePoint(opponentTeam);
                awaitingServeReturn = false;
                return;
              }
              // Serve is in, so set awaitingServeReturn true for the receiver's chance
              awaitingServeReturn = true;
              // Do not return; allow normal hit logic to proceed
            }
            // --- Bounce-based out detection ---
            // (No need to set any hasBouncedIn or firstServeBounce flags)
            // Determine which team should receive the bounce (who is the opponent?)
            // If last hitter was team 1 (player 0 or 1), bounce must be on team 2's side (top half)
            // If last hitter was team 2 (player 2 or 3), bounce must be on team 1's side (bottom half)
            let lastHitterIdx =
              allowedHitter < 2 ? lastHitter[1] : lastHitter[0];
            let hitterTeam = lastHitterIdx < 2 ? 1 : 2;
            let opponentTeam = hitterTeam === 1 ? 2 : 1;
            // Table bounds
            const left = table.x;
            const right = table.x + table.width;
            const top = table.y;
            const bottom = table.y + table.height;
            // Ball must land on opponent's half (including lines)
            let inBounds = false;
            if (hitterTeam === 1) {
              // Ball must land on top half (team 2's side)
              inBounds =
                bouncePing.x >= left &&
                bouncePing.x <= right &&
                bouncePing.y >= top &&
                bouncePing.y <= table.netY;
            } else {
              // Ball must land on bottom half (team 1's side)
              inBounds =
                bouncePing.x >= left &&
                bouncePing.x <= right &&
                bouncePing.y >= table.netY &&
                bouncePing.y <= bottom;
            }
            if (!inBounds) {
              let hitterTeam = players[lastHitterIndex].team;
              let opponentTeam = hitterTeam === 1 ? 2 : 1;
              scorePoint(opponentTeam);
              // awaitingServeReturn = false; // <-- REMOVE THIS LINE
              return;
            } else {
              // Only set awaitingServeReturn for the first bounce after a serve
              // if (awaitingServeReturn) {
              //   awaitingServeReturn = false;
              // }
            }
            // --- End bounce-based out detection ---
          }
        }
      }

      function switchHitter() {
        // Doubles rules: alternate within team, then switch teams
        if (gameState.currentHitter === 0) gameState.currentHitter = 2;
        else if (gameState.currentHitter === 2) gameState.currentHitter = 1;
        else if (gameState.currentHitter === 1) gameState.currentHitter = 3;
        else if (gameState.currentHitter === 3) gameState.currentHitter = 0;
      }

      // --- AI LOGIC IMPROVEMENTS ---
      function predictBallLandingX() {
        // Simple prediction: where will the ball cross the AI's y line?
        let t;
        let targetY;
        if (allowedHitter === 2) {
          targetY = players[2].y + 20; // Top AI
          if (ball.vy === 0) return ball.x;
          t = (targetY - ball.y) / ball.vy;
        } else if (allowedHitter === 3) {
          targetY = players[3].y + 20; // Top AI
          if (ball.vy === 0) return ball.x;
          t = (targetY - ball.y) / ball.vy;
        } else {
          return ball.x;
        }
        return ball.x + ball.vx * t;
      }

      function updateAI() {
        // Allow AI opponents to move further outside the table
        const margin = -canvas.width * 0.3;
        if (!gameState.ballInPlay) {
          // Before the serve, both AIs stay at their default positions
          players[2].targetX = table.x + table.width * 0.3;
          players[3].targetX = table.x + table.width * 0.7;
          players[2].x += (players[2].targetX - players[2].x) * 0.15;
          players[3].x += (players[3].targetX - players[3].x) * 0.15;
          return;
        }
        if (ballStuck && stuckPlayer === 0) {
          // While user is charging/aiming, both AIs stay where they are
          return;
        }
        if (ballStuckToAI || aiCharging) {
          // While AI is charging/hitting, both AIs stay where they are
          return;
        }
        // During gameplay, only allowedHitter AI moves to predicted spot, other AI does nothing
        [2, 3].forEach((i) => {
          if (i === allowedHitter) {
            const player = players[i];
            const predictedX = Math.max(
              margin,
              Math.min(canvas.width - margin, predictBallLandingX())
            );
            player.targetX = predictedX;
            player.x += (player.targetX - player.x) * 0.15;
          }
          // The other AI does nothing (stays wherever they are)
        });
      }

      // Replace AI hit logic in updateBall with robust AI charging/hit gating
      // The AI charging and power meter logic is now handled within the players.forEach loop
      // The alternation and hit logic is also handled within the players.forEach loop

      function updatePlayers() {
        // User movement
        const margin = -canvas.width * 0.3;
        players[0].x += (players[0].targetX - players[0].x) * 0.2;
        // AI teammate (player 1)
        if (ballStuck && stuckPlayer === 0) {
          // AI teammate returns to default position
          players[1].targetX = table.x + table.width * 0.7;
        } else {
          if (allowedHitter === 1 && ball.y > table.netY) {
            // It's their turn, move toward ball
            players[1].targetX = Math.max(
              margin,
              Math.min(canvas.width - margin, ball.x)
            );
          } else {
            // Default position
            players[1].targetX = table.x + table.width * 0.7;
          }
        }
        players[1].x += (players[1].targetX - players[1].x) * 0.1;
      }

      function scorePoint(team) {
        if (team === 1) {
          gameState.score1++;
          document.getElementById("score1").textContent = gameState.score1;
        } else {
          gameState.score2++;
          document.getElementById("score2").textContent = gameState.score2;
        }

        gameState.ballInPlay = false;
        ball.trail = [];

        // Check win condition
        if (gameState.score1 >= 15 || gameState.score2 >= 15) {
          gameState.gameWon = true;
          // Show win message with color and pulse
          const winMsg = team === 1 ? "Blue Team Wins!" : "Red Team Wins!";
          const winColor = team === 1 ? "#2196F3" : "#F44336";
          const gameInfo = document.getElementById("gameInfo");
          gameInfo.textContent = winMsg;
          gameInfo.style.color = winColor;
          gameInfo.classList.add("winPulse");
          // Show new game button
          document.getElementById("newGameBtn").style.display = "block";
          return;
        }

        // Next serve
        gameState.servesLeft--;
        if (gameState.servesLeft <= 0) {
          serveRotationIndex = (serveRotationIndex + 1) % serveRotation.length;
          gameState.currentServer = serveRotation[serveRotationIndex];
          gameState.servesLeft = 5;
        }

        gameState.currentHitter = gameState.currentServer;
        // Show 'Serving: Player...' for 3s, then switch to instructions
        document.getElementById("gameInfo").textContent = `Serving: Player ${
          gameState.currentServer + 1
        } (Serves left: ${gameState.servesLeft})`;

        // --- IMMEDIATE SERVE RESET LOGIC (was inside setTimeout) ---
        const serveSpots = [
          {
            x: table.x + table.width * 0.3,
            y: table.y + table.height * 0.94,
          },
          {
            x: table.x + table.width * 0.7,
            y: table.y + table.height * 0.94,
          },
          {
            x: table.x + table.width * 0.3,
            y: table.y + table.height * 0.06,
          },
          {
            x: table.x + table.width * 0.7,
            y: table.y + table.height * 0.06,
          },
        ];
        const server = gameState.currentServer;
        players[server].x = players[server].targetX = serveSpots[server].x;
        players[server].y = serveSpots[server].y;
        if (server === 0 || server === 1) {
          players[0].x = players[0].targetX = serveSpots[0].x;
          players[0].y = serveSpots[0].y;
          players[1].x = players[1].targetX = serveSpots[1].x;
          players[1].y = serveSpots[1].y;
        }
        if (server === 2 || server === 3) {
          players[2].x = players[2].targetX = serveSpots[2].x;
          players[2].y = serveSpots[2].y;
          players[3].x = players[3].targetX = serveSpots[3].x;
          players[3].y = serveSpots[3].y;
        }
        ball.x = players[server].x;
        if (server === 0 || server === 1) {
          ball.y = players[server].y - 50;
        } else {
          ball.y = players[server].y + 50;
        }
        ball.vx = 0;
        ball.vy = 0;
        hasBouncedIn = false;
        hasBouncedSinceLastHit = false;

        // --- Clean alternation logic on serve reset ---
        const diagonal = [3, 2, 1, 0];
        if (server === 0) {
          allowedHitter = 0;
          gameState.currentHitter = 0;
        } else {
          allowedHitter = diagonal[server];
          gameState.currentHitter = diagonal[server];
        }
        // Set lastHitter so alternation works for all four servers
        if (server < 2) {
          lastHitter = [server, diagonal[server]];
        } else {
          lastHitter = [diagonal[server], server];
        }
        // --- END IMMEDIATE SERVE RESET LOGIC ---

        // If the server is an AI, trigger AI serve after a short delay
        if (server !== 0) {
          setTimeout(() => {
            // AI serve: 85-90% chance of going in on the correct quadrant
            let placement;
            let rand = Math.random();
            let targetX;
            const centerX = table.x + table.width / 2;
            if (rand < 0.875) {
              // 87.5% chance: serve in, aim for center of correct quadrant
              placement = 0.55 + Math.random() * 0.35; // 0.55-0.9
              // Determine target x for correct quadrant
              if (server === 0 || server === 2) {
                // Right half
                targetX =
                  centerX +
                  table.width / 4 +
                  (Math.random() - 0.5) * (table.width / 6);
              } else {
                // Left half
                targetX =
                  centerX -
                  table.width / 4 +
                  (Math.random() - 0.5) * (table.width / 6);
              }
            } else {
              // 12.5% chance: serve out (either short or long, random side)
              placement =
                Math.random() < 0.5
                  ? 0.2 + Math.random() * 0.28
                  : 0.91 + Math.random() * 0.09;
              // Out serves: aim randomly across the table
              targetX = table.x + Math.random() * table.width;
            }
            // Calculate angle to targetX at far end line
            let fromX = players[server].x;
            let fromY = players[server].y;
            let toY =
              server === 0 || server === 1 ? table.y : table.y + table.height;
            let toX = targetX;
            let angle =
              Math.atan2(toY - fromY, toX - fromX) +
              (Math.random() - 0.5) * 0.12;
            const fixedSpeed = 4;
            let vx = Math.cos(angle) * fixedSpeed;
            let vy = Math.sin(angle) * fixedSpeed;
            ball.vx = vx;
            ball.vy = vy;
            gameState.ballInPlay = true;
            // After the serve, set allowedHitter to the diagonal opponent
            const diagonal = [3, 2, 1, 0];
            allowedHitter = diagonal[server];
            gameState.currentHitter = diagonal[server];
            // Set bounce state for AI serve
            const bounce = getBounceLocation(
              players[server].x,
              players[server].y,
              placement,
              server === 0 || server === 1,
              vx,
              vy
            );
            bounceState = {
              x: bounce.x,
              y: bounce.y,
              shown: false,
              color: "#fff",
            };
            hasBouncedIn = false;
            // Set gameplay instructions as soon as gameplay starts
            setGameplayInstructions();
          }, 600);
        }

        // After serve reset, show instructions after 2s
        setTimeout(() => {
          if (gameState.currentServer === 0) {
            document.getElementById("gameInfo").textContent =
              "Your serve! Hold to aim & power";
          } else {
            document.getElementById("gameInfo").textContent =
              "Click/tap to move, hold to aim & power";
          }
        }, 2000);
        ballStuck = false;
        stuckPlayer = null;
        hasBounced = false;
        isServeInProgress = true;
        awaitingServeReturn = false;
      }

      function getInputPosition(e) {
        const rect = canvas.getBoundingClientRect();
        if (e.touches) {
          const touch = e.touches[0] || e.changedTouches[0];
          return {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top,
          };
        } else {
          return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top,
          };
        }
      }

      function handleInputStart(e) {
        e.preventDefault();
        const pos = getInputPosition(e);
        if (ballStuck && stuckPlayer === 0 && !charging) {
          inputStart = pos;
          charging = true;
          chargePower = 0;
          // aimArrow.style.display = "block"; // Removed
          return;
        }
        // Prevent user movement before serve if user is server
        if (!gameState.ballInPlay && allowedHitter === 0) {
          // Only allow charging for serve, not movement
          if (!charging) {
            inputStart = pos;
            charging = true;
            chargePower = 0;
            // aimArrow.style.display = "block"; // Removed
          }
          return;
        }
        // Only allow user to move on click/tap (not mousemove)
        const margin = -canvas.width * 0.3;
        if (pos.y > table.netY) {
          players[0].targetX = Math.max(
            margin,
            Math.min(canvas.width - margin, pos.x)
          );
        }
      }

      function handleInputMove(e) {
        if (!charging) {
          // Prevent user movement before serve if user is server
          const pos = getInputPosition(e);
          if (!gameState.ballInPlay && allowedHitter === 0) {
            return;
          }
          // Do NOT move player on mousemove/touchmove anymore
          return;
        }
        e.preventDefault();

        // Only allow aiming if serve or ball is stuck to user
        if (
          !(
            (!gameState.ballInPlay && allowedHitter === 0) ||
            (ballStuck && stuckPlayer === 0)
          )
        ) {
          return;
        }
        // Block user power meter updates if AI is charging
        if (
          aiCharging ||
          showingAIPlacement ||
          (currentPlacementOwner && currentPlacementOwner !== "user")
        )
          return;

        if (ballStuck && stuckPlayer === 0 && charging) {
          const pos = getInputPosition(e);
          const dx = inputStart.x - pos.x;
          const dy = inputStart.y - pos.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          chargePower = Math.min(distance / 100, 1);
          aimAngle = Math.atan2(dy, dx);
          currentPlacementOwner = "user";
          powerFill.style.background =
            "linear-gradient(to top, #ff4444, #ffff44, #44ff44)";
          powerFill.style.height = chargePower * 100 + "%";
          const player = players[0];
          const arrowLength = 40 + chargePower * 60;
          aimingArrowState = {
            x: player.x,
            y: player.y,
            angle: aimAngle,
            length: arrowLength,
            visible: true,
          };
          return;
        }

        // Serve aiming
        if (!gameState.ballInPlay && allowedHitter === 0 && charging) {
          const pos = getInputPosition(e);
          const dx = inputStart.x - pos.x; // Reverse direction
          const dy = inputStart.y - pos.y; // Reverse direction
          const distance = Math.sqrt(dx * dx + dy * dy);

          chargePower = Math.min(distance / 100, 1);
          aimAngle = Math.atan2(dy, dx);

          // Update power meter
          currentPlacementOwner = "user";
          powerFill.style.background =
            "linear-gradient(to top, #ff4444, #ffff44, #44ff44)";
          powerFill.style.height = chargePower * 100 + "%";

          // Update aim arrow
          const player = players[0];
          const arrowLength = 40 + chargePower * 60;
          aimingArrowState = {
            x: player.x,
            y: player.y,
            angle: aimAngle,
            length: arrowLength,
            visible: true,
          };
        }
      }

      function handleInputEnd(e) {
        // Only allow hitting if serve or ball is stuck to user
        if (
          !(
            (!gameState.ballInPlay && allowedHitter === 0) ||
            (ballStuck && stuckPlayer === 0)
          )
        ) {
          charging = false;
          // aimArrow.style.display = "none"; // Removed
          if (
            !showingAIPlacement &&
            (!currentPlacementOwner || currentPlacementOwner === "user")
          ) {
            // powerFill.style.height = "0%"; // Removed
            currentPlacementOwner = null;
          }
          aimingArrowState.visible = false;
          return;
        }

        if (ballStuck && stuckPlayer === 0 && charging) {
          charging = false;
          // aimArrow.style.display = "none"; // Removed
          if (
            !showingAIPlacement &&
            (!currentPlacementOwner || currentPlacementOwner === "user")
          ) {
            // powerFill.style.height = "0%"; // Removed
            currentPlacementOwner = null;
          }
          // Hit the ball
          lastHitterIndex = 0; // User is always player 0
          hasBouncedSinceLastHit = false;
          const fixedSpeed = 4;
          ball.vx = Math.cos(aimAngle) * fixedSpeed;
          ball.vy = Math.sin(aimAngle) * fixedSpeed;
          ballStuck = false;
          stuckPlayer = null;
          // Set bounce state for user shot
          const bounce = getBounceLocation(
            players[0].x,
            players[0].y,
            chargePower,
            true,
            ball.vx,
            ball.vy
          );
          bounceState = {
            x: bounce.x,
            y: bounce.y,
            shown: false,
            color: "#fff",
          };
          hasBouncedIn = false;
          aimingArrowState.visible = false;
          awaitingServeReturn = false;
          return;
        }
        if (!charging) return;
        e.preventDefault();
        charging = false;
        // aimArrow.style.display = "none"; // Removed
        if (
          !showingAIPlacement &&
          (!currentPlacementOwner || currentPlacementOwner === "user")
        ) {
          // powerFill.style.height = "0%"; // Removed
          currentPlacementOwner = null;
        }
        aimingArrowState.visible = false;

        if (chargePower > 0.1) {
          // Serve or hit the ball
          lastHitterIndex = 0; // User is always player 0
          hasBouncedSinceLastHit = false;
          const fixedSpeed = 4; // Stronger serve
          ball.vx = Math.cos(aimAngle) * fixedSpeed;
          ball.vy = Math.sin(aimAngle) * fixedSpeed;
          gameState.ballInPlay = true;

          if (gameState.currentHitter === gameState.currentServer) {
            // Set allowedHitter to diagonal opponent after serve
            // 03, 12, 21, 30
            const diagonal = [3, 2, 1, 0];
            allowedHitter = diagonal[gameState.currentServer];
            gameState.currentHitter = allowedHitter;
          }
          // Set bounce state for user serve
          const bounce = getBounceLocation(
            players[0].x,
            players[0].y,
            chargePower,
            true,
            ball.vx,
            ball.vy
          );
          bounceState = {
            x: bounce.x,
            y: bounce.y,
            shown: false,
            color: "#fff",
          };
          // Set gameplay instructions as soon as gameplay starts
          setGameplayInstructions();
        }
      }

      // Add this helper function at the top level, after other helpers
      function getBounceLocation(
        fromX,
        fromY,
        placement,
        isUser,
        vx = 0,
        vy = 0
      ) {
        // Linear interpolation from hitter's paddle to far end line
        let startY = fromY;
        let endY = isUser ? table.y : table.y + table.height;
        // Clamp placement between 0 and 1
        placement = Math.max(0, Math.min(1, placement));
        // Bounce location is a linear interpolation
        const targetY = startY + (endY - startY) * placement;

        // Calculate the predicted x-coordinate where the ball will land
        // This is a simplified prediction based on current velocity and placement
        // A more accurate prediction would involve physics simulation
        let predictedX = fromX;
        if (vy !== 0) {
          // Predict where the ball will cross the targetY line
          const t = (targetY - fromY) / vy;
          predictedX = fromX + vx * t;
        } else {
          // If vy is 0, the ball is moving horizontally.
          // The bounce will happen at the targetY line.
          predictedX = fromX;
        }

        return { x: predictedX, y: targetY };
      }

      // Add this function at the top level, after other helpers:
      function setGameplayInstructions() {
        document.getElementById("gameInfo").textContent =
          "Click/tap to move, hold to aim & power";
      }

      // Add this function at the top level, after other helpers:
      function drawAimingArrow() {
        if (!aimingArrowState.visible) return;
        const { x, y, angle, length } = aimingArrowState;
        ctx.save();
        ctx.strokeStyle = "rgba(220,220,220,0.7)";
        ctx.fillStyle = "rgba(220,220,220,0.7)";
        ctx.lineWidth = 3;
        ctx.lineCap = "round";
        // Calculate triangle base and tip
        const headLength = 14;
        const headWidth = 10;
        const tipX = x + Math.cos(angle) * length;
        const tipY = y + Math.sin(angle) * length;
        const baseCenterX = tipX - Math.cos(angle) * headLength;
        const baseCenterY = tipY - Math.sin(angle) * headLength;
        // Draw main arrow line from player to base center
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(baseCenterX, baseCenterY);
        ctx.stroke();
        // Draw triangle arrowhead
        const leftX =
          baseCenterX + Math.cos(angle + Math.PI / 2) * (headWidth / 2);
        const leftY =
          baseCenterY + Math.sin(angle + Math.PI / 2) * (headWidth / 2);
        const rightX =
          baseCenterX + Math.cos(angle - Math.PI / 2) * (headWidth / 2);
        const rightY =
          baseCenterY + Math.sin(angle - Math.PI / 2) * (headWidth / 2);
        ctx.beginPath();
        ctx.moveTo(tipX, tipY);
        ctx.lineTo(leftX, leftY);
        ctx.lineTo(rightX, rightY);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      // Event listeners for both touch and mouse
      canvas.addEventListener("touchstart", handleInputStart);
      canvas.addEventListener("touchmove", handleInputMove);
      window.addEventListener("touchend", handleInputEnd);
      canvas.addEventListener("mousedown", handleInputStart);
      canvas.addEventListener("mousemove", handleInputMove);
      window.addEventListener("mouseup", handleInputEnd);

      // Prevent context menu on right click
      canvas.addEventListener("contextmenu", (e) => e.preventDefault());

      let isMenuOpen = false;
      let gamePaused = false;
      let animationFrameId = null;

      function pauseGame() {
        gamePaused = true;
      }
      function resumeGame() {
        gamePaused = false;
        gameLoop();
      }

      // Override gameLoop to respect pause
      function gameLoop() {
        if (gamePaused) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawTable();
        updatePlayers();
        drawPlayers();
        drawBall();
        drawAimingArrow();
        if (!gameState.gameWon) {
          updateBall();
          updateAI();
        }
        animationFrameId = requestAnimationFrame(gameLoop);
      }

      // Menu button logic
      const menuBtn = document.getElementById("menuBtn");
      const menuModal = document.getElementById("menuModal");
      const closeMenuBtn = document.getElementById("closeMenuBtn");
      const restartBtn = document.getElementById("restartBtn");
      const buyBtn = document.getElementById("buyBtn");
      let menuOpen = false;
      // Ensure menu is closed on page load
      menuModal.style.display = "none";
      menuOpen = false;
      menuBtn.onclick = function () {
        menuOpen = !menuOpen;
        if (menuOpen) {
          isMenuOpen = true;
          pauseGame();
          menuModal.style.display = "block";
          menuModal.style.transform = "translateY(0)";
        } else {
          isMenuOpen = false;
          menuModal.style.display = "none";
          resumeGame();
        }
      };
      closeMenuBtn.onclick = function () {
        menuOpen = false;
        isMenuOpen = false;
        menuModal.style.display = "none";
        resumeGame();
      };
      // Clicking outside the modal closes it (optional, not required by user)
      menuModal.addEventListener("click", function (e) {
        if (e.target === menuModal) {
          menuOpen = false;
          isMenuOpen = false;
          menuModal.style.display = "none";
          resumeGame();
        }
      });
      // Rules section logic
      const rulesSection = document.getElementById("rulesSection");
      const rulesModal = document.getElementById("rulesModal");
      rulesSection.onclick = function () {
        if (rulesModal.style.display === "none") {
          rulesModal.style.display = "block";
          rulesSection.querySelector("p").textContent = "Click to hide rules";
        } else {
          rulesModal.style.display = "none";
          rulesSection.querySelector("p").textContent = "Click to view rules";
        }
      };
      // Controls section logic
      const controlsSection = document.getElementById("controlsSection");
      const controlsList = document.getElementById("controlsList");
      const controlsToggleMsg = document.getElementById("controlsToggleMsg");
      controlsSection.onclick = function () {
        if (controlsList.style.display === "none") {
          controlsList.style.display = "block";
          controlsToggleMsg.textContent = "Click to hide controls";
        } else {
          controlsList.style.display = "none";
          controlsToggleMsg.textContent = "Click to view controls";
        }
      };
      // Restart New Game button
      restartBtn.onclick = function () {
        // Simulate new game button click
        document.getElementById("newGameBtn").click();
        menuOpen = false;
        isMenuOpen = false;
        menuModal.style.display = "none";
        resumeGame();
      };
      // Buy button
      buyBtn.onclick = function () {
        window.open("https://lobpong.co/products/lob-pong-game-set", "_blank");
      };

      // Initialize and start game
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);
      isServeInProgress = true;
      gameLoop();

      // Reset win message style and color when starting a new game
      function resetWinMessage() {
        const gameInfo = document.getElementById("gameInfo");
        gameInfo.classList.remove("winPulse");
        gameInfo.style.color = "#fff";
      }

      // New Game button handler
      document.getElementById("newGameBtn").onclick = function () {
        // Reset all game state
        gameState.score1 = 0;
        gameState.score2 = 0;
        gameState.currentServer = 0;
        gameState.servesLeft = 5;
        gameState.currentHitter = 0;
        gameState.ballInPlay = false;
        gameState.gameWon = false;
        serveRotationIndex = 0;
        lastHitter = [0, 2];
        allowedHitter = 0;
        ballStuck = false;
        stuckPlayer = null;
        aiPlacement = 0;
        aiPlacementTimeout = null;
        showingAIPlacement = false;
        currentPlacementOwner = null;
        aiCharging = false;
        aiWaitingForBallToLeave = false;
        aiChargingPlayer = null;
        ballStuckToAI = false;
        lastAIHitter = null;
        bouncePing = null;
        bounceState = null;
        teammatePlacement = 0;
        hasBounced = false;
        hasBouncedIn = false;
        aimingArrowState = { x: 0, y: 0, angle: 0, length: 0, visible: false };
        hasBouncedSinceLastHit = false;
        isServeInProgress = true;
        flightStartY = null;
        flightEndY = null;
        flightActive = false;
        firstServeBounce = true;
        // Reset scores in UI
        document.getElementById("score1").textContent = 0;
        document.getElementById("score2").textContent = 0;
        // Hide new game button
        document.getElementById("newGameBtn").style.display = "none";
        // Reset win message style
        resetWinMessage();
        // Reset player and ball positions
        resizeCanvas();
        // Show serve info
        document.getElementById(
          "gameInfo"
        ).textContent = `Serving: Player 1 (Serves left: 5)`;
        setTimeout(() => {
          document.getElementById("gameInfo").textContent =
            "Your serve! Hold to aim & power";
        }, 2000);
      };
    </script>
  </body>
</html>
